name: Cross-Platform Environment Validation

on:
  workflow_dispatch:
    inputs:
      validation_type:
        description: 'Type of validation to run'
        required: false
        default: 'full'
        type: choice
        options:
        - secrets
        - environment
        - connectivity
        - full
  schedule:
    - cron: '0 6 * * 1'  # Weekly on Monday at 6 AM UTC

permissions:
  contents: read

env:
  NODE_VERSION: '20'
  PYTHON_VERSION: '3.11'

jobs:
  validate-environment:
    name: 'Environment Validation - ${{ matrix.os }}'
    strategy:
      matrix:
        include:
          - os: 'ubuntu-latest'
            shell: bash
            platform: 'linux'
          - os: 'ubuntu-latest'
            shell: pwsh
            platform: 'windows'
    runs-on: ${{ fromJSON(matrix.os) }}
    timeout-minutes: 15
    defaults:
      run:
        shell: ${{ matrix.shell }}

    steps:
      - name: 'Structured Log - Validation Start'
        run: |
          if ($IsWindows -or $env:OS -like "*Windows*") {
            Write-Host (@{level="info"; message="Environment validation started"; platform="${{ matrix.platform }}"; validation_type="${{ github.event.inputs.validation_type || 'full' }}"; timestamp=(Get-Date -Format "yyyy-MM-ddTHH:mm:ssZ")} | ConvertTo-Json -Compress)
          } else {
            echo '{"level":"info","message":"Environment validation started","platform":"${{ matrix.platform }}","validation_type":"${{ github.event.inputs.validation_type || 'full' }}","timestamp":"'$(date -u +%Y-%m-%dT%H:%M:%SZ)'"}'
          fi

      - uses: actions/checkout@v4

      - name: 'Validate Required Secrets'
        if: github.event.inputs.validation_type == 'secrets' || github.event.inputs.validation_type == 'full' || github.event.inputs.validation_type == ''
        run: |
          if ($IsWindows -or $env:OS -like "*Windows*") {
            Write-Host (@{level="info"; message="Validating required secrets on Windows"} | ConvertTo-Json -Compress)
            
            $secretsToCheck = @(
              @{name="ORG_GITHUB_TOKEN"; value="${{ secrets.ORG_GITHUB_TOKEN }}"; required=$false},
              @{name="ORG_SLACK_WEBHOOK"; value="${{ secrets.ORG_SLACK_WEBHOOK }}"; required=$false},
              @{name="ORG_AUDIT_WEBHOOK"; value="${{ secrets.ORG_AUDIT_WEBHOOK }}"; required=$false},
              @{name="SHOPIFY_GRAPHQL_TOKEN"; value="${{ secrets.SHOPIFY_GRAPHQL_TOKEN }}"; required=$false},
              @{name="SUPABASE_SERVICE_ROLE_KEY"; value="${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}"; required=$false}
            )
            
            $missingRequired = @()
            $availableOptional = @()
            
            foreach ($secret in $secretsToCheck) {
              if ([string]::IsNullOrEmpty($secret.value)) {
                if ($secret.required) {
                  $missingRequired += $secret.name
                  Write-Host (@{level="error"; message="Required secret missing"; secret=$secret.name} | ConvertTo-Json -Compress)
                } else {
                  Write-Host (@{level="warn"; message="Optional secret not configured"; secret=$secret.name} | ConvertTo-Json -Compress)
                }
              } else {
                $availableOptional += $secret.name
                Write-Host (@{level="info"; message="Secret available"; secret=$secret.name} | ConvertTo-Json -Compress)
              }
            }
            
            if ($missingRequired.Count -gt 0) {
              Write-Host (@{level="error"; message="Required secrets missing"; secrets=$missingRequired} | ConvertTo-Json -Compress)
              throw "Missing required secrets: $($missingRequired -join ', ')"
            }
            
            Write-Host (@{level="info"; message="Secret validation completed"; available_secrets=$availableOptional.Count; total_secrets=$secretsToCheck.Count} | ConvertTo-Json -Compress)
          } else {
            echo '{"level":"info","message":"Validating required secrets on Linux"}'
            
            # Check secrets (non-required for now)
            secrets_checked=0
            secrets_available=0
            
            check_secret() {
              local name=$1
              local value=$2
              local required=${3:-false}
              
              secrets_checked=$((secrets_checked + 1))
              
              if [ -z "$value" ]; then
                if [ "$required" = "true" ]; then
                  echo '{"level":"error","message":"Required secret missing","secret":"'$name'"}'
                  return 1
                else
                  echo '{"level":"warn","message":"Optional secret not configured","secret":"'$name'"}'
                fi
              else
                secrets_available=$((secrets_available + 1))
                echo '{"level":"info","message":"Secret available","secret":"'$name'"}'
              fi
              return 0
            }
            
            check_secret "ORG_GITHUB_TOKEN" "${{ secrets.ORG_GITHUB_TOKEN }}" false
            check_secret "ORG_SLACK_WEBHOOK" "${{ secrets.ORG_SLACK_WEBHOOK }}" false  
            check_secret "ORG_AUDIT_WEBHOOK" "${{ secrets.ORG_AUDIT_WEBHOOK }}" false
            check_secret "SHOPIFY_GRAPHQL_TOKEN" "${{ secrets.SHOPIFY_GRAPHQL_TOKEN }}" false
            check_secret "SUPABASE_SERVICE_ROLE_KEY" "${{ secrets.SUPABASE_SERVICE_ROLE_KEY }}" false
            
            echo '{"level":"info","message":"Secret validation completed","available_secrets":'$secrets_available',"total_secrets":'$secrets_checked'}'
          fi

      - name: 'Validate Environment Variables'
        if: github.event.inputs.validation_type == 'environment' || github.event.inputs.validation_type == 'full' || github.event.inputs.validation_type == ''
        run: |
          if ($IsWindows -or $env:OS -like "*Windows*") {
            Write-Host (@{level="info"; message="Validating environment variables on Windows"} | ConvertTo-Json -Compress)
            
            # Test environment variables access
            Write-Host (@{level="info"; message="Environment info"; user=$env:USERNAME; computer=$env:COMPUTERNAME; os=$env:OS} | ConvertTo-Json -Compress)
            
            # Test PowerShell capabilities
            $psVersion = $PSVersionTable.PSVersion
            Write-Host (@{level="info"; message="PowerShell version"; version=$psVersion.ToString()} | ConvertTo-Json -Compress)
            
            # Test JSON handling
            $testJson = @{test="value"; number=42} | ConvertTo-Json -Compress
            Write-Host (@{level="info"; message="JSON handling test"; json=$testJson} | ConvertTo-Json -Compress)
            
            # Test retry capability simulation
            $maxAttempts = 3
            for ($i = 1; $i -le $maxAttempts; $i++) {
              try {
                Write-Host (@{level="info"; message="Retry test attempt"; attempt=$i} | ConvertTo-Json -Compress)
                if ($i -eq 2) { break }  # Simulate success on 2nd attempt
              } catch {
                if ($i -lt $maxAttempts) {
                  Start-Sleep -Seconds 1
                } else {
                  throw $_
                }
              }
            }
            Write-Host (@{level="info"; message="Retry logic test passed"} | ConvertTo-Json -Compress)
          } else {
            echo '{"level":"info","message":"Validating environment variables on Linux"}'
            
            # Test environment variables access
            echo '{"level":"info","message":"Environment info","user":"'$USER'","hostname":"'$HOSTNAME'","shell":"'$SHELL'"}'
            
            # Test bash capabilities
            bash_version="$BASH_VERSION"
            echo '{"level":"info","message":"Bash version","version":"'$bash_version'"}'
            
            # Test JSON handling (using jq if available, otherwise basic)
            if command -v jq >/dev/null 2>&1; then
              test_json='{"test":"value","number":42}'
              echo '{"level":"info","message":"JSON handling test with jq","json":'$test_json'}'
            else
              echo '{"level":"info","message":"JSON handling test basic","json":"{\"test\":\"value\",\"number\":42}"}'
            fi
            
            # Test retry capability simulation
            echo '{"level":"info","message":"Testing retry logic"}'
            for i in {1..3}; do
              echo '{"level":"info","message":"Retry test attempt","attempt":'$i'}'
              if [ $i -eq 2 ]; then
                break  # Simulate success on 2nd attempt
              fi
              sleep 1
            done
            echo '{"level":"info","message":"Retry logic test passed"}'
          fi

      - name: 'Test Network Connectivity'
        if: github.event.inputs.validation_type == 'connectivity' || github.event.inputs.validation_type == 'full' || github.event.inputs.validation_type == ''
        uses: nick-fields/retry@v3
        with:
          timeout_minutes: 5
          max_attempts: 3
          retry_wait_seconds: 10
          retry_on: error
          command: |
            if ($IsWindows -or $env:OS -like "*Windows*") {
              Write-Host (@{level="info"; message="Testing network connectivity on Windows"} | ConvertTo-Json -Compress)
              
              $endpoints = @(
                @{name="GitHub API"; url="https://api.github.com"},
                @{name="npm registry"; url="https://registry.npmjs.org"},
                @{name="PyPI"; url="https://pypi.org/simple/"},
                @{name="GitHub raw content"; url="https://raw.githubusercontent.com"}
              )
              
              $results = @()
              foreach ($endpoint in $endpoints) {
                try {
                  $response = Invoke-WebRequest -Uri $endpoint.url -TimeoutSec 10 -UseBasicParsing
                  $results += @{name=$endpoint.name; status="success"; status_code=$response.StatusCode}
                  Write-Host (@{level="info"; message="Endpoint accessible"; name=$endpoint.name; status_code=$response.StatusCode} | ConvertTo-Json -Compress)
                } catch {
                  $results += @{name=$endpoint.name; status="failed"; error=$_.Exception.Message}
                  Write-Host (@{level="warn"; message="Endpoint not accessible"; name=$endpoint.name; error=$_.Exception.Message} | ConvertTo-Json -Compress)
                }
              }
              
              $successCount = ($results | Where-Object {$_.status -eq "success"}).Count
              Write-Host (@{level="info"; message="Network connectivity test completed"; successful_endpoints=$successCount; total_endpoints=$endpoints.Count} | ConvertTo-Json -Compress)
              
              if ($successCount -eq 0) {
                throw "No network endpoints accessible"
              }
            } else {
              echo '{"level":"info","message":"Testing network connectivity on Linux"}'
              
              endpoints=(
                "GitHub API|https://api.github.com"
                "npm registry|https://registry.npmjs.org"
                "PyPI|https://pypi.org/simple/"
                "GitHub raw content|https://raw.githubusercontent.com"
              )
              
              success_count=0
              total_count=${#endpoints[@]}
              
              for endpoint in "${endpoints[@]}"; do
                name=$(echo $endpoint | cut -d'|' -f1)
                url=$(echo $endpoint | cut -d'|' -f2)
                
                if curl -f -s --max-time 10 "$url" >/dev/null 2>&1; then
                  echo '{"level":"info","message":"Endpoint accessible","name":"'$name'","url":"'$url'"}'
                  success_count=$((success_count + 1))
                else
                  echo '{"level":"warn","message":"Endpoint not accessible","name":"'$name'","url":"'$url'"}'
                fi
              done
              
              echo '{"level":"info","message":"Network connectivity test completed","successful_endpoints":'$success_count',"total_endpoints":'$total_count'}'
              
              if [ $success_count -eq 0 ]; then
                echo '{"level":"error","message":"No network endpoints accessible"}'
                exit 1
              fi
            fi

      - name: 'Test Cross-Platform Tool Installation'
        if: github.event.inputs.validation_type == 'full' || github.event.inputs.validation_type == ''
        run: |
          if ($IsWindows -or $env:OS -like "*Windows*") {
            Write-Host (@{level="info"; message="Testing tool installation on Windows"} | ConvertTo-Json -Compress)
            
            # Test Node.js installation
            try {
              if (Get-Command node -ErrorAction SilentlyContinue) {
                $nodeVersion = node --version
                Write-Host (@{level="info"; message="Node.js available"; version=$nodeVersion} | ConvertTo-Json -Compress)
              } else {
                Write-Host (@{level="warn"; message="Node.js not available"} | ConvertTo-Json -Compress)
              }
            } catch {
              Write-Host (@{level="warn"; message="Node.js check failed"; error=$_.Exception.Message} | ConvertTo-Json -Compress)
            }
            
            # Test Python installation
            try {
              if (Get-Command python -ErrorAction SilentlyContinue) {
                $pythonVersion = python --version
                Write-Host (@{level="info"; message="Python available"; version=$pythonVersion} | ConvertTo-Json -Compress)
              } else {
                Write-Host (@{level="warn"; message="Python not available"} | ConvertTo-Json -Compress)
              }
            } catch {
              Write-Host (@{level="warn"; message="Python check failed"; error=$_.Exception.Message} | ConvertTo-Json -Compress)
            }
            
            # Test Git installation
            try {
              if (Get-Command git -ErrorAction SilentlyContinue) {
                $gitVersion = git --version
                Write-Host (@{level="info"; message="Git available"; version=$gitVersion} | ConvertTo-Json -Compress)
              } else {
                Write-Host (@{level="warn"; message="Git not available"} | ConvertTo-Json -Compress)
              }
            } catch {
              Write-Host (@{level="warn"; message="Git check failed"; error=$_.Exception.Message} | ConvertTo-Json -Compress)
            }
          } else {
            echo '{"level":"info","message":"Testing tool installation on Linux"}'
            
            # Test Node.js installation
            if command -v node >/dev/null 2>&1; then
              node_version=$(node --version)
              echo '{"level":"info","message":"Node.js available","version":"'$node_version'"}'
            else
              echo '{"level":"warn","message":"Node.js not available"}'
            fi
            
            # Test Python installation
            if command -v python3 >/dev/null 2>&1; then
              python_version=$(python3 --version)
              echo '{"level":"info","message":"Python available","version":"'$python_version'"}'
            elif command -v python >/dev/null 2>&1; then
              python_version=$(python --version)
              echo '{"level":"info","message":"Python available","version":"'$python_version'"}'
            else
              echo '{"level":"warn","message":"Python not available"}'
            fi
            
            # Test Git installation
            if command -v git >/dev/null 2>&1; then
              git_version=$(git --version)
              echo '{"level":"info","message":"Git available","version":"'$git_version'"}'
            else
              echo '{"level":"warn","message":"Git not available"}'
            fi
          fi

      - name: 'Generate Environment Report'
        if: always()
        run: |
          if ($IsWindows -or $env:OS -like "*Windows*") {
            Write-Host (@{level="info"; message="Generating environment report"; platform="Windows"} | ConvertTo-Json -Compress)
            
            $report = @{
              platform = "Windows"
              timestamp = (Get-Date -Format "yyyy-MM-ddTHH:mm:ssZ")
              runner_info = @{
                os = $env:OS
                user = $env:USERNAME
                computer = $env:COMPUTERNAME
                powershell_version = $PSVersionTable.PSVersion.ToString()
              }
              validation_results = @{
                secrets_check = "${{ job.status }}"
                environment_check = "${{ job.status }}"
                connectivity_check = "${{ job.status }}"
                tools_check = "${{ job.status }}"
              }
            }
            
            $reportJson = $report | ConvertTo-Json -Depth 5 -Compress
            Add-Content -Path $env:GITHUB_ENV -Value "ENVIRONMENT_REPORT=$reportJson" -Encoding utf8
            Write-Host (@{level="info"; message="Environment report generated"} | ConvertTo-Json -Compress)
          } else {
            echo '{"level":"info","message":"Generating environment report","platform":"Linux"}'
            
            # Create environment report JSON
            timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)
            os_info=$(uname -s)
            report_json='{"platform":"Linux","timestamp":"'$timestamp'","runner_info":{"os":"'$os_info'","user":"'$USER'","hostname":"'$HOSTNAME'","shell":"'$SHELL'","bash_version":"'$BASH_VERSION'"},"validation_results":{"secrets_check":"${{ job.status }}","environment_check":"${{ job.status }}","connectivity_check":"${{ job.status }}","tools_check":"${{ job.status }}"}}'
            
            echo "ENVIRONMENT_REPORT=$report_json" >> $GITHUB_ENV
            echo '{"level":"info","message":"Environment report generated"}'
          fi

      - name: 'Structured Log - Validation Complete'
        if: always()
        run: |
          if ($IsWindows -or $env:OS -like "*Windows*") {
            Write-Host (@{level="info"; message="Environment validation completed"; status="${{ job.status }}"; platform="${{ matrix.platform }}"; timestamp=(Get-Date -Format "yyyy-MM-ddTHH:mm:ssZ")} | ConvertTo-Json -Compress)
          } else {
            echo '{"level":"info","message":"Environment validation completed","status":"${{ job.status }}","platform":"${{ matrix.platform }}","timestamp":"'$(date -u +%Y-%m-%dT%H:%M:%SZ)'"}'
          fi

      - name: 'Notify on Failure'
        if: failure() && (secrets.ORG_SLACK_WEBHOOK || vars.ORG_SLACK_WEBHOOK)
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.ORG_SLACK_WEBHOOK || vars.ORG_SLACK_WEBHOOK }}
        run: |
          if ($IsWindows -or $env:OS -like "*Windows*") {
            Write-Host (@{level="error"; message="Environment validation failed, sending notification"} | ConvertTo-Json -Compress)
            $slackMessage = @{
              text = "🚨 Royal Equips Environment Validation Failed"
              attachments = @(
                @{
                  color = "danger"
                  fields = @(
                    @{ title = "Platform"; value = "${{ matrix.platform }}"; short = $true }
                    @{ title = "Validation Type"; value = "${{ github.event.inputs.validation_type || 'full' }}"; short = $true }
                    @{ title = "Run ID"; value = "${{ github.run_id }}"; short = $true }
                    @{ title = "Repository"; value = "${{ github.repository }}"; short = $true }
                  )
                }
              )
            } | ConvertTo-Json -Depth 5 -Compress
            Invoke-RestMethod -Uri $env:SLACK_WEBHOOK_URL -Method Post -Body $slackMessage -ContentType "application/json"
          } else {
            echo '{"level":"error","message":"Environment validation failed, sending notification"}'
            curl -X POST -H 'Content-type: application/json' \
              --data '{"text":"🚨 Royal Equips Environment Validation Failed: ${{ matrix.platform }} - ${{ github.event.inputs.validation_type || 'full' }} (Run #${{ github.run_id }})"}' \
              "$SLACK_WEBHOOK_URL"
          fi