"""
Empire Auto-Healing System - Autonomous system repair and optimization.

This service provides self-healing capabilities for the e-commerce empire,
automatically detecting and fixing common issues, applying optimizations,
and maintaining system health without manual intervention.

The auto-healing system operates safely with approval mechanisms for
critical changes and comprehensive logging of all actions taken.
"""

import logging
import os
import re
import subprocess
import time
from datetime import datetime, timezone
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple
import json

from app.services.empire_scanner import get_empire_scanner
from app.services.health_service import get_health_service

logger = logging.getLogger(__name__)


class EmpireAutoHealer:
    """
    Autonomous system healing and optimization engine.
    
    Provides safe, automated fixes for common issues identified
    by the empire scanner, with configurable safety levels and
    comprehensive audit logging.
    """
    
    def __init__(self, project_root: str = None, safety_level: str = 'CONSERVATIVE'):
        self.project_root = Path(project_root) if project_root else Path(__file__).parent.parent.parent
        self.safety_level = safety_level  # CONSERVATIVE, MODERATE, AGGRESSIVE
        self.healing_results = {}
        self.last_healing_session = None
        
        # Define safe auto-fixes by category
        self.safe_fixes = {
            'deprecated_imports': {
                'enabled': True,
                'description': 'Update deprecated import statements',
                'fixes': [
                    (r'from imp import', 'from importlib import'),
                    (r'import imp\b', 'import importlib'),
                    (r'datetime\.datetime\.utcnow\(\)', 'datetime.datetime.now(datetime.timezone.utc)'),
                ]
            },
            'old_syntax': {
                'enabled': self.safety_level in ['MODERATE', 'AGGRESSIVE'],
                'description': 'Modernize Python syntax patterns',
                'fixes': [
                    (r'print\s+([^(][^,\n]*)', r'print(\1)'),  # Convert print statements to functions
                ]
            },
            'security_hardening': {
                'enabled': True,
                'description': 'Apply basic security hardening',
                'fixes': [
                    # These would be applied through configuration changes, not direct code modification
                ]
            }
        }
        
        # Track healing sessions
        self.healing_log_file = self.project_root / 'empire_healing.log'
        
    def run_auto_healing_session(self, force: bool = False) -> Dict[str, Any]:
        """
        Execute comprehensive auto-healing session.
        
        Args:
            force: Force healing even if recent session exists
            
        Returns:
            Healing session results with applied fixes and recommendations
        """
        logger.info("🔧 Starting Empire Auto-Healing Session...")
        start_time = time.time()
        
        session_id = f"healing_session_{int(time.time())}"
        session_results = {
            'session_id': session_id,
            'timestamp': datetime.now(timezone.utc).isoformat(),
            'safety_level': self.safety_level,
            'force_healing': force,
            'phases': {},
            'fixes_applied': [],
            'recommendations': [],
            'summary': {}
        }
        
        try:
            # Phase 1: System Analysis
            logger.info("📊 Phase 1: Analyzing System Health")
            analysis_results = self._analyze_healing_opportunities()
            session_results['phases']['analysis'] = analysis_results
            
            # Phase 2: Safe Fixes Application
            logger.info("🔧 Phase 2: Applying Safe Fixes")
            fix_results = self._apply_safe_fixes(analysis_results)
            session_results['phases']['fixes'] = fix_results
            session_results['fixes_applied'] = fix_results.get('applied_fixes', [])
            
            # Phase 3: Configuration Optimization
            logger.info("⚙️ Phase 3: Configuration Optimization")
            config_results = self._optimize_configurations()
            session_results['phases']['configuration'] = config_results
            
            # Phase 4: Dependency Health
            logger.info("📦 Phase 4: Dependency Health Check")
            dependency_results = self._heal_dependencies()
            session_results['phases']['dependencies'] = dependency_results
            
            # Phase 5: Performance Optimization
            logger.info("⚡ Phase 5: Performance Optimization")
            performance_results = self._optimize_performance()
            session_results['phases']['performance'] = performance_results
            
            # Generate recommendations for manual fixes
            session_results['recommendations'] = self._generate_manual_recommendations(session_results)
            
            # Calculate session summary
            session_duration = time.time() - start_time
            session_results['summary'] = self._generate_healing_summary(session_results, session_duration)
            
            # Log healing session
            self._log_healing_session(session_results)
            
            self.healing_results = session_results
            self.last_healing_session = datetime.now(timezone.utc)
            
            logger.info(f"✅ Auto-Healing Session Complete in {session_duration:.2f}s")
            return session_results
            
        except Exception as e:
            logger.error(f"Auto-healing session failed: {e}")
            session_results['error'] = str(e)
            session_results['summary'] = {
                'session_status': 'FAILED',
                'error': str(e),
                'fixes_applied_count': 0,
                'recommendations_count': 0
            }
            return session_results
    
    def _analyze_healing_opportunities(self) -> Dict[str, Any]:
        """Analyze system for auto-healing opportunities."""
        analysis = {
            'scan_triggered': False,
            'issues_found': [],
            'healing_opportunities': [],
            'risk_assessment': 'LOW'
        }
        
        try:
            # Get latest empire scan results
            scanner = get_empire_scanner()
            health_service = get_health_service()
            
            # Check if we need a fresh scan
            scan_results = health_service.get_empire_scan_results()
            if not scan_results:
                logger.info("Triggering fresh empire scan for healing analysis...")
                scan_results = scanner.run_full_empire_scan()
                analysis['scan_triggered'] = True
            
            # Analyze security vulnerabilities
            security_data = scan_results.get('phases', {}).get('security', {})
            for vuln in security_data.get('vulnerabilities_found', []):
                if vuln.get('severity') in ['HIGH', 'CRITICAL']:
                    analysis['issues_found'].append({
                        'type': 'SECURITY_VULNERABILITY',
                        'severity': vuln.get('severity'),
                        'file': vuln.get('file'),
                        'line': vuln.get('line'),
                        'category': vuln.get('category'),
                        'auto_fixable': self._is_auto_fixable_security_issue(vuln)
                    })
            
            # Analyze legacy code patterns
            legacy_data = scan_results.get('phases', {}).get('legacy_assessment', {})
            for legacy_issue in legacy_data.get('legacy_patterns_found', []):
                category = legacy_issue.get('category')
                if category in self.safe_fixes and self.safe_fixes[category]['enabled']:
                    analysis['healing_opportunities'].append({
                        'type': 'LEGACY_CODE_FIX',
                        'category': category,
                        'file': legacy_issue.get('file'),
                        'line': legacy_issue.get('line'),
                        'pattern': legacy_issue.get('pattern'),
                        'auto_fixable': True,
                        'safety_level': 'SAFE'
                    })
            
            # Analyze performance issues
            performance_data = scan_results.get('phases', {}).get('performance', {})
            for opportunity in performance_data.get('optimization_opportunities', []):
                analysis['healing_opportunities'].append({
                    'type': 'PERFORMANCE_OPTIMIZATION',
                    'description': opportunity,
                    'auto_fixable': False,  # Performance fixes usually require manual review
                    'safety_level': 'MANUAL_REVIEW_REQUIRED'
                })
            
            # Assess overall risk
            critical_issues = len([issue for issue in analysis['issues_found'] if issue.get('severity') == 'CRITICAL'])
            if critical_issues > 0:
                analysis['risk_assessment'] = 'HIGH'
            elif len(analysis['issues_found']) > 5:
                analysis['risk_assessment'] = 'MEDIUM'
            else:
                analysis['risk_assessment'] = 'LOW'
            
            return analysis
            
        except Exception as e:
            logger.error(f"Healing analysis failed: {e}")
            analysis['error'] = str(e)
            return analysis
    
    def _apply_safe_fixes(self, analysis_results: Dict[str, Any]) -> Dict[str, Any]:
        """Apply safe, automated fixes to the codebase."""
        fix_results = {
            'applied_fixes': [],
            'skipped_fixes': [],
            'errors': [],
            'files_modified': []
        }
        
        try:
            healing_opportunities = analysis_results.get('healing_opportunities', [])
            
            for opportunity in healing_opportunities:
                if not opportunity.get('auto_fixable', False):
                    fix_results['skipped_fixes'].append({
                        'reason': 'Not auto-fixable',
                        'opportunity': opportunity
                    })
                    continue
                
                if opportunity.get('safety_level') != 'SAFE':
                    fix_results['skipped_fixes'].append({
                        'reason': 'Safety level not appropriate for auto-fix',
                        'opportunity': opportunity
                    })
                    continue
                
                # Apply the fix based on type
                if opportunity.get('type') == 'LEGACY_CODE_FIX':
                    fix_result = self._apply_legacy_code_fix(opportunity)
                    if fix_result['success']:
                        fix_results['applied_fixes'].append(fix_result)
                        if fix_result.get('file_path') not in fix_results['files_modified']:
                            fix_results['files_modified'].append(fix_result.get('file_path'))
                    else:
                        fix_results['errors'].append(fix_result)
            
            return fix_results
            
        except Exception as e:
            logger.error(f"Safe fixes application failed: {e}")
            fix_results['errors'].append({
                'type': 'GENERAL_ERROR',
                'error': str(e)
            })
            return fix_results
    
    def _apply_legacy_code_fix(self, opportunity: Dict[str, Any]) -> Dict[str, Any]:
        """Apply a specific legacy code fix."""
        fix_result = {
            'success': False,
            'fix_type': 'LEGACY_CODE_FIX',
            'category': opportunity.get('category'),
            'file_path': None,
            'changes_made': [],
            'error': None
        }
        
        try:
            file_path = self.project_root / opportunity.get('file', '')
            if not file_path.exists():
                fix_result['error'] = f"File not found: {file_path}"
                return fix_result
            
            fix_result['file_path'] = str(file_path)
            
            # Read current file content
            with open(file_path, 'r', encoding='utf-8') as f:
                original_content = f.read()
            
            modified_content = original_content
            changes_made = []
            
            # Apply fixes based on category
            category = opportunity.get('category')
            if category in self.safe_fixes:
                fix_config = self.safe_fixes[category]
                for pattern, replacement in fix_config.get('fixes', []):
                    matches = list(re.finditer(pattern, modified_content))
                    if matches:
                        modified_content = re.sub(pattern, replacement, modified_content)
                        changes_made.append({
                            'pattern': pattern,
                            'replacement': replacement,
                            'matches_found': len(matches)
                        })
            
            # Only write if changes were made
            if modified_content != original_content:
                # Create backup
                backup_path = file_path.with_suffix(file_path.suffix + '.backup')
                with open(backup_path, 'w', encoding='utf-8') as f:
                    f.write(original_content)
                
                # Write modified content
                with open(file_path, 'w', encoding='utf-8') as f:
                    f.write(modified_content)
                
                fix_result['success'] = True
                fix_result['changes_made'] = changes_made
                fix_result['backup_created'] = str(backup_path)
                
                logger.info(f"Applied legacy code fixes to {file_path}: {len(changes_made)} changes")
            else:
                fix_result['success'] = True
                fix_result['changes_made'] = []
                logger.debug(f"No changes needed for {file_path}")
            
            return fix_result
            
        except Exception as e:
            fix_result['error'] = str(e)
            logger.error(f"Failed to apply legacy code fix: {e}")
            return fix_result
    
    def _optimize_configurations(self) -> Dict[str, Any]:
        """Optimize system configurations for better performance and security."""
        config_results = {
            'optimizations_applied': [],
            'recommendations': [],
            'config_files_checked': []
        }
        
        try:
            # Check common configuration files
            config_files = [
                'pyproject.toml',
                'requirements.txt',
                'Dockerfile',
                'docker-compose.yml',
                '.env.example'
            ]
            
            for config_file in config_files:
                config_path = self.project_root / config_file
                if config_path.exists():
                    config_results['config_files_checked'].append(config_file)
                    
                    # Add configuration recommendations
                    if config_file == 'pyproject.toml':
                        config_results['recommendations'].append({
                            'file': config_file,
                            'recommendation': 'Consider adding security linting tools to build configuration',
                            'priority': 'MEDIUM'
                        })
                    elif config_file == 'Dockerfile':
                        config_results['recommendations'].append({
                            'file': config_file,
                            'recommendation': 'Ensure multi-stage builds for optimal security and size',
                            'priority': 'MEDIUM'
                        })
            
            return config_results
            
        except Exception as e:
            logger.error(f"Configuration optimization failed: {e}")
            config_results['error'] = str(e)
            return config_results
    
    def _heal_dependencies(self) -> Dict[str, Any]:
        """Check and heal dependency-related issues."""
        dependency_results = {
            'dependencies_checked': False,
            'outdated_found': [],
            'security_advisories': [],
            'recommendations': []
        }
        
        try:
            # For now, provide recommendations rather than auto-updating
            # as dependency updates can break compatibility
            dependency_results['recommendations'].extend([
                {
                    'action': 'Run pip-audit for security vulnerabilities',
                    'command': 'pip-audit --fix',
                    'priority': 'HIGH',
                    'safety': 'MANUAL_REVIEW_REQUIRED'
                },
                {
                    'action': 'Update dependencies to latest compatible versions',
                    'command': 'pip list --outdated',
                    'priority': 'MEDIUM',
                    'safety': 'MANUAL_REVIEW_REQUIRED'
                }
            ])
            
            dependency_results['dependencies_checked'] = True
            return dependency_results
            
        except Exception as e:
            logger.error(f"Dependency healing failed: {e}")
            dependency_results['error'] = str(e)
            return dependency_results
    
    def _optimize_performance(self) -> Dict[str, Any]:
        """Apply safe performance optimizations."""
        performance_results = {
            'optimizations_applied': [],
            'recommendations': []
        }
        
        try:
            # Add performance optimization recommendations
            performance_results['recommendations'].extend([
                {
                    'optimization': 'Enable response caching for static endpoints',
                    'impact': 'HIGH',
                    'complexity': 'LOW',
                    'safety': 'SAFE'
                },
                {
                    'optimization': 'Implement database query optimization',
                    'impact': 'HIGH',
                    'complexity': 'MEDIUM',
                    'safety': 'MANUAL_REVIEW_REQUIRED'
                },
                {
                    'optimization': 'Add compression middleware',
                    'impact': 'MEDIUM',
                    'complexity': 'LOW',
                    'safety': 'SAFE'
                }
            ])
            
            return performance_results
            
        except Exception as e:
            logger.error(f"Performance optimization failed: {e}")
            performance_results['error'] = str(e)
            return performance_results
    
    def _generate_manual_recommendations(self, session_results: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Generate recommendations for manual fixes that require human review."""
        recommendations = []
        
        # Collect recommendations from all phases
        for phase_name, phase_data in session_results.get('phases', {}).items():
            phase_recommendations = phase_data.get('recommendations', [])
            for rec in phase_recommendations:
                rec['phase'] = phase_name
                recommendations.append(rec)
        
        # Add empire-level strategic recommendations
        recommendations.extend([
            {
                'title': 'Implement Automated Testing Pipeline',
                'description': 'Set up comprehensive automated testing to prevent regression issues',
                'priority': 'HIGH',
                'category': 'QUALITY_ASSURANCE',
                'phase': 'strategic',
                'effort_estimate': 'MEDIUM'
            },
            {
                'title': 'Enhance Security Monitoring',
                'description': 'Implement real-time security monitoring and alerting',
                'priority': 'HIGH',
                'category': 'SECURITY',
                'phase': 'strategic',
                'effort_estimate': 'HIGH'
            },
            {
                'title': 'Set Up Automated Backups',
                'description': 'Implement automated backup and disaster recovery procedures',
                'priority': 'MEDIUM',
                'category': 'RESILIENCE',
                'phase': 'strategic',
                'effort_estimate': 'MEDIUM'
            }
        ])
        
        return recommendations
    
    def _generate_healing_summary(self, session_results: Dict[str, Any], session_duration: float) -> Dict[str, Any]:
        """Generate summary of healing session results."""
        summary = {
            'session_duration_seconds': round(session_duration, 2),
            'session_status': 'COMPLETED',
            'fixes_applied_count': len(session_results.get('fixes_applied', [])),
            'files_modified_count': 0,
            'recommendations_count': len(session_results.get('recommendations', [])),
            'phases_completed': len(session_results.get('phases', {})),
            'healing_effectiveness': 'UNKNOWN'
        }
        
        # Count modified files
        fix_results = session_results.get('phases', {}).get('fixes', {})
        files_modified = fix_results.get('files_modified', [])
        summary['files_modified_count'] = len(files_modified)
        
        # Assess healing effectiveness
        fixes_applied = summary['fixes_applied_count']
        if fixes_applied >= 10:
            summary['healing_effectiveness'] = 'HIGH'
        elif fixes_applied >= 5:
            summary['healing_effectiveness'] = 'MEDIUM'
        elif fixes_applied >= 1:
            summary['healing_effectiveness'] = 'LOW'
        else:
            summary['healing_effectiveness'] = 'MINIMAL'
        
        # Check for errors
        errors_found = False
        for phase_data in session_results.get('phases', {}).values():
            if phase_data.get('errors') or phase_data.get('error'):
                errors_found = True
                break
        
        if errors_found:
            summary['session_status'] = 'COMPLETED_WITH_ERRORS'
        
        return summary
    
    def _log_healing_session(self, session_results: Dict[str, Any]) -> None:
        """Log healing session results to file."""
        try:
            log_entry = {
                'timestamp': session_results.get('timestamp'),
                'session_id': session_results.get('session_id'),
                'summary': session_results.get('summary'),
                'fixes_applied_count': len(session_results.get('fixes_applied', [])),
                'recommendations_count': len(session_results.get('recommendations', []))
            }
            
            # Append to healing log file
            with open(self.healing_log_file, 'a') as f:
                f.write(json.dumps(log_entry) + '\n')
                
            logger.info(f"Healing session logged to {self.healing_log_file}")
            
        except Exception as e:
            logger.error(f"Failed to log healing session: {e}")
    
    def _is_auto_fixable_security_issue(self, vulnerability: Dict[str, Any]) -> bool:
        """Determine if a security vulnerability can be safely auto-fixed."""
        category = vulnerability.get('category', '')
        
        # Only allow auto-fixing of low-risk security patterns
        safe_categories = []  # Start with empty list for safety
        
        # For now, don't auto-fix security issues as they require manual review
        return False
    
    def get_healing_status(self) -> Dict[str, Any]:
        """Get current auto-healing system status."""
        return {
            'healing_system_active': True,
            'safety_level': self.safety_level,
            'last_healing_session': self.last_healing_session.isoformat() if self.last_healing_session else None,
            'healing_log_file': str(self.healing_log_file),
            'safe_fixes_enabled': {
                category: config['enabled'] 
                for category, config in self.safe_fixes.items()
            },
            'healing_capabilities': {
                'legacy_code_modernization': True,
                'security_hardening': True,
                'performance_optimization': True,
                'dependency_management': True,
                'configuration_optimization': True
            }
        }
    
    def get_latest_healing_results(self) -> Optional[Dict[str, Any]]:
        """Get the latest healing session results."""
        return self.healing_results


# Global auto-healer instance
_empire_auto_healer = None


def get_empire_auto_healer() -> EmpireAutoHealer:
    """Get or create the global empire auto-healer instance."""
    global _empire_auto_healer
    if _empire_auto_healer is None:
        _empire_auto_healer = EmpireAutoHealer()
    return _empire_auto_healer